### 网络层核心概念与功能

网络层不再是一个端到端的层次。

网络层的核心功能：转发与路由。**转发**：将分组从路由器的输入端口转移到合适的输出端口上去。根据什么来进行转发呢？每个路由器需要配备专发表，根据数据报中的地址来确定转发出去的端口。**路由**：确定分组从源到目的经过的路径。根据路由算法（协议）确定通过网络的端到端路径。

某些网络需要**连接建立**功能，比如ATM网络等。数据分组传输之前两端主机需要首先建立虚拟/逻辑连接。其与传输层的连接不一样，网络层的连接需要路径上所有的路由器参与该连接。网络层的连接是主机到主机的连接（要明确路径，路径上的路由器都要记录该连接）；传输层的连接是应用进程之间的连接（只是端系统之间的连接，对中间的网络是透明的）。

### 网络层服务模型

网络层为数据报提供什么服务呢？不同的网络提供的服务是不同的。比如Internet提供的是Best Effort的服务，也就是尽力而为的服务，不提供任何保障也没有反馈。ATM网络（异步传输模式网络）比如CBR/VBR/ABR/UBR（分别都有不同的保障和功能）。

无连接服务：不事先为一系列分组的传输确定传输路径；每个分组独立确定传输路径（路由器根据当前网络状况确定）；同一系列的不同分组走的路径可能是完全不同的（所以顺序可能发生混乱）。代表：数据报网络。

连接服务：首先为系列分组的传输确定从源到目的经过的路径（建立连接）；沿着路径（连接）传输分组；系列分组传输路径相同；传输结束后拆除连接。代表：虚电路网络。

### 虚电路网络

网络层的无连接和连接服务类似于传输层的UDP和TCP，但是网络层的服务是主机到主机的服务，且在网络核心实现（传输层是端到端的）。

虚电路：一条从源到目的的路径（逻辑连接，和电路交换类似，但注意它是分组交换）。电路交换可以使用复用技术，可以不需要占用链路的所有物理资源，但是分组交换需要占用所有的物理资源，这是电路交换和分组交换的最大差异。而虚电路本质上是分组交换，所以也会利用链路的所有带宽。整个路径经过的所有网络设备共同完成虚电路功能。

虚电路通信过程（借鉴电路交换思想，采用分组交换技术）：呼叫建立（call setup）->数据传输->拆除呼叫。电路建立的时候分配一个标识（VCID），让分组携带VCID，携带相同的VCID的分组就会经过同一个路径。虚电路经过的每个设备都参与维护虚电路的连接状态。

虚电路的优点：有预分配资源，可预期服务性能。

虚电路的具体实现。虚电路包括：从源到目的的一条路径、虚电路号VCID（不同的链路带宽不同，承载的虚电路数量不同，虚电路号也不可能相同，所以**同一条虚电路中每一段链路采用的虚电路号是不一样的**）、沿路每个设备利用转发表记录经过的每条虚电路。每个分组携带的不是目的地址而是VCID，路由器转发分组时依据转发表**改写/替换**虚电路号（因为同一条VC，每段链路上的VCID一般不同）。

![虚电路转发表示意](http://book.moecode.com/net/layer3/1.png)

虚电路信令协议，用于VC的建立、维护和拆除，包括路径选择（建立的过程中选路）

![虚电路流程](http://book.moecode.com/net/layer3/2.png)

### 数据报网络

代表性网络：Internet

特点：网络层无连接，所以每个分组都需要携带目的地址，于是路由器需要根据分组的目的地址转发分组（基于路由协议/算法构建转发表）。每个分组是独立选路的。

遇到的问题：IPv4的地址空间是40多亿，不可能将具体的IP地址存下来，所以应该使用地址范围。

地址匹配方法：如果所有都不匹配则选择“其他”，也就是默认匹配；如果有多个匹配的，则根据最长前缀匹配优先原则来进行匹配（越长越具体，选更具体的）。

![地址匹配](http://book.moecode.com/net/layer3/3.png)

### IP数据报

- 路由协议：进行路径选择，比如RIP、OSPF、BGP

- 转发表（路由表）

- IP协议：寻址规约、数据报格式、分组处理规约

- ICMP协议：传输过程中的差错报告、路由器信令

IP数据报（分组）：首部+数据（TCP/UDP段），首部分为固定部分（20字节）和可变部分（可以没有）。

![IP数据报](http://book.moecode.com/net/layer3/4.png)

版本号 4bit：4或6，对应IP协议版本

首部长度 4bit：最大值是15，以四个字节为单位，也就是图中的一行。这个值乘以4才是首部的字节数。比如如果没有可变部分，首部长度值为5（*4 = 20）

服务类型TOS 8bit：1998年改名“区分服务”，只有在网络真正提供区分服务时才使用。事实上一般不使用，所以IP数据报第二个字节一般取00H

总长度 16bit：16位，IP分组的总字节数（首部+数据）。最大IP分组长度65535B，最小20B，可以封装最大数据65515B

生存时间TTL 8bit：IP分组在网络中可以通过的路由器数（跳数），路由器每转发一次TTL就减1，如果减到0则被网络丢弃，路由器会向原主机发送ICMP报文。

协议 8bit：TCP还是UDP，实现复用/分解。比如6为TCP，17为UDP

首部校验和 16bit：计算校验和时该字段置为零进行计算，采用反码算术运算求和，和的反码作为首部校验和字段（这样计算时使得校验变得简单）。由于数据报传输过程中首部会发生变化（比如TTL），所以每一跳校验和都要重新计算重新校验。

源、目的IP地址 32bit * 2

选项字段1-40B：携带安全、源选路径、时间戳、路由记录等，很少使用

填充 0-3B：使整个首部是4字节的倍数

### IP分片与重组

最大传输单元MTU：链路层数据帧可封装数据的上限，不同的网络可以有不同的MTU，当一个IP分组从MTU较大的网络进入到MTU较小的网络时可能装不下，**可以**进行分片。

注意：是否能够分组要看数据报里面的标识位，如果不让分片则只能丢弃，并向原主机发送ICMP报文。

IP分片到达目的主机后进行重组。路由器只负责分片，而不进行组装。IP首部的相关字段用于标识分片以及确定其相对顺序。如果有分片没收到，则超过阈值时间后主机会将所有分片都丢弃。

涉及到：总长度、标识、标志位、片偏移四个字段。

标识ID 16bit：唯一地标识IP分组。

标志位 3bit：保留+DF+MF。DF（Don't Fragment），MF（More Fragment）。DF为1意为禁止分片，为0表示允许分片。MF为1表示非最后一片，为0表示最后一片或没分片。

片偏移 13bit：一个IP分组的分片封装原IP分组数据的相对偏移量。可见如果没有分片时其一定是0。根据片偏移的相对大小可以对分片进行排序，最大的看其MF。如果没有分片则MF为0且片偏移也为0。

特别注意：片偏移字段以8字节为单位。因为总长度字段的长度大于片偏移字段长度，如果片偏移字段也采用字节为单位，则装不下。进一步地，所有分片除了最后一片，其数据字节数一定是8的倍数。

IP分片过程：假设原分组总长度L，待转发链路的MTU为M，在L>M且DF=0的情况下进行分片。分片时每个分片的标识复制原IP分组的标识，除最后一个分片外其他分片均采用MTU所允许的最大值。

该最大值计算公式：d=[(M-20)/8]*8。注意这里的取整为下取整，取整后的值意思是总长M去掉首部长（典型值为20）所能容纳最多的8的个数，再乘以8得到所允许的最大数据长度。d再加上20就得到该分片的总长度。

该分组报文所需要的总的分片数为：n=[(L-20)/d]。这里的取整为上取整，意思是L去掉首部之后需要多少个d来容纳，当然用上取整。

每片的片偏移字段取值：F(i)=d/8*(i-1), 1<=i<=n。注意片偏移字段以8字节为单位，d一定是8的倍数。

每片的总长度字段为：当1<=i<n时为d+20，当i=n时为L-(n-1)*d。

每片的MF标志位：最后一个是0，其余为1。

### IP编址

IP编址实际上是对网络接口进行编址，IPv4采用32bit的编号对主机和路由器的接口进行标识。可以采用点分十进制的表示方法对地址进行表示。

IP子网：高比特部分称为网络号NetID，低比特部分称为主机号HostID，具有相同网络号的网络接口构成IP子网。

IP子网内的接口可以不跨越路由器进行彼此的物理联通。

IP的“有类”编址：ABC类占用87.5%，D用作组播/多播，E类留作研究使用

![“有类”编址](http://book.moecode.com/net/layer3/5.png)

注意就算是ABC类也不是所有的地址都能分配给主机使用，有一些是特殊地址：

![特殊地址](http://book.moecode.com/net/layer3/6.png)

当一个主机不明确自己的IP地址但是仍要使用IP协议发送分组的时候用0.0.0.0，也就是只能用作源地址。本网广播地址和直接广播地址的区别：如果所要广播的网络是自己所在的子网，用前者即可；如果不是自己所在的则一定要用后者。环回地址比如127.0.0.1。其余详见图片。

还有一部分特殊的地址称为私有IP地址，只在内部网络使用。在公共互联网上这些地址是非法的，因为它们是不唯一的。正是由于私有地址和NAT技术，即使当前IPv4的地址已经被分配完了，互联网仍能正常运行。

![私有地址](http://book.moecode.com/net/layer3/7.png)

### IP子网划分与子网掩码

IP地址：网络号NetID+子网号SubID+主机号HostID。SubID从主机号的高比特部分截取。

子网划分的一个重要目的：在路由器中根据子网号对数据报进行转发，有效地隔离流量。

一个重要的问题：如何确定是否划分了子网？利用了多少位进行子网的划分？用子网掩码来解决。

子网掩码：形式和IP地址一样，32位点分十进制，取值为NetID和SubID位全部取1，HostID全取0。

注意：只有子网地址（网络地址）是不能够确定子网的大小的（比如子网号的低位为0就不知道那些位是属于子网号还是属于主机号了）。而子网地址和子网掩码结合能够准确地确定子网的大小。

![子网划分举例](http://book.moecode.com/net/layer3/8.png)

路由器存储子网地址时还需存储子网掩码，才能合理分流。将IP分组的目的IP地址与子网掩码按位与运算后得到子网地址。

注意区分地址范围和可分配地址范围：后者要去掉主机号全0和全1的。

### CIDR与路由聚合

有类编址不够灵活。CIDR：无类域间路由。消除了传统的ABC类地址的界限。CIDR将NetID和SubID合称为网络前缀Prefix，可以是任意长度。融合了子网地址与子网掩码，方便子网划分。

无类地址格式：a.b.c.d/x，x为前缀长度。

比如下面图示的地址就不符合有类地址划分的原则，其实际上可以看作两个C类地址的聚合。

![一个例子](http://book.moecode.com/net/layer3/9.png)

CIDR可以提高地址空间的分配效率和路由效率。后者是因为可以将多个子网聚合在一起构成较大的子网（超网），在路由中可以面向这个超网而不需要面向那个更小的子网，这种技术叫做“路由聚集”。这种技术使得路由表的大小更小了，提高效率。

比如223.1.0.0/23、223.1.2.0/24、223.1.3.0/24三者可以合并成223.1.0.0/22（三者中第一个的空间大小等于第二、三个之和），从而将路由表中的3个项变成1个。

最长前缀匹配原则可以解决路由黑洞问题，如图所示。详见MOOC。

![路由黑洞问题](http://book.moecode.com/net/layer3/10.png)

### DHCP协议

主机如何获得IP地址？

- 硬编码：静态配置
- 动态主机配置协议DHCP：从服务器动态获取IP地址、子网掩码、默认网关地址、DNS服务器名称与IP地址。即插即用，允许地址重用（关闭后还回去）、支持在用地址的续租、支持移动用户加入网络

流程：主机广播发现报文（DHCP discover），因为其不知道是否有DHCP服务器。然后DHCP服务器利用提供报文（DHCP offer）进行响应，主机请求IP地址发送请求报文（DHCP request），之后DHCP服务器分配IP地址发送确认报文（DHCP ack）。

DHCP工作过程示意图如下。一开始主机的源地址时0.0.0.0因为它还没有确定自己的IP地址，目的地址时255.255.255.255即受限广播地址，本网络中的所有接口包括DHCP服务器都能收到；当一台DHCP服务器收到发现报文后进行广播响应，并带上了预分配的地址yiaddr（your ip address），注意此处的交互用transaction ID进行标识，这样就不会有两台正在发送发现报文的主机同时想使用这个yiaddr；接下来主机就发送请求报文，这时候主机虽然有了目的服务器的地址，但是仍然使用广播的形式，这是因为网络中可能存在多台DHCP服务器，需要让其他的服务器知道自己准备用某台服务器分配的yiaddr地址，这样一来其他服务器就能将自己预分配给这台主机的IP地址收回，供其他人使用；最后服务器以广播形式发送确认报文，这时候主机才最终得到了自己的IP地址。

![DHCP工作流程示意图](http://book.moecode.com/net/layer3/11.png)

DHCP实际上是在应用层中以应用进程的形式实现的，DHCP封装在UDP中，进一步封装在IP中等等。

### NAT网络地址转换

![NAT](http://book.moecode.com/net/layer3/12.png)

NAT的动机：一个网络只能/只需从ISP申请一个IP地址（因为IPv4地址耗尽或出于管理方便），本地网络设备IP地址的更变无需向外界通告（内部网络地址全部使用私有地址），变更ISP时无需修改内部网络IP地址，内部网络设备对外部网络不可见即不可直接寻址（安全性考虑）。

NAT实现步骤：

- 替换：利用（NAT IP地址，新端口号）来替换每个外出IP数据报的（源IP地址，源端口号）
- 记录：将每对（NAT IP地址，新端口号）和（源IP地址，源端口号）的替换信息存储到NAT转换表中
- 替换：根据NAT转换表，利用（源IP地址，源端口号）替换每个进入内网IP数据报的（目的IP地址，目的端口号），即（NAT IP地址，新端口号）

![工作流程示意图](http://book.moecode.com/net/layer3/13.png)

16bit的端口号可以支持六万多个并行的连接。

NAT的主要争议：其违背了端到端通信的原则。端口号实际上是传输层的概念，而路由器要完成的是网络层的处理，在NAT技术中路由器管理NAT转发表，实际上就是处理传输层的信息，也就是说网络层必须考虑到传输层的存在，违背了“传输层数据对网络层是透明的”这样一个事实。

如何实现NAT的转换（穿透）？

- 静态配置NAT，将特定端口的连接服务请求转发给服务器
- 利用互联网网关设备协议（UPnP自动配置）：获得NAT公共地址并在其转换表中增删端口映射
- 中继：中继服务器分别与NAT内部客户与外部客户建立连接，比如Skype

### ICMP互联网控制报文协议

两个主要功能：支持主机/路由器完成差错报告，可以发送特殊类型ICMP报文进行网络探询

差错报告报文：

- 目的不可达报文
- 源抑制：当路由器发现缓存已满导致丢包时，发送源抑制报文，通告主机降低发送速度
- 超时/超期：与TTL有关，当TTL为0时发送
- 参数问题：如果路由器认为报文首部某些域有问题时发送
- 重定向：当路由器认为该报文不应该经过它来到达目的主机时发送，通告主机进行重定向

网络探询报文：

- 回声请求/应答报文：主机想探测某目的主机是否可达，比如Ping工具
- 时间戳请求/应答报文

ICMP报文由类型和编码共同确定。

![报文类型](http://book.moecode.com/net/layer3/14.png)

并不是所有情况都要发送ICMP报文，例外有：

![不发送ICMP报文的情况](http://book.moecode.com/net/layer3/15.png)

ICMP报文的结构

![报文结构](http://book.moecode.com/net/layer3/16.png)

ICMP报文有8个字节的头部，ICMP差错报告报文的数据部分如下图所示。其数据部分封装了发生差错的IP数据报的完整的IP数据报首部和接下来的8个字节。如果IP数据报封装的是UDP报文，UDP报文的首部刚好时8个字节，那么ICMP报文的数据部分包括了完整的IP数据报首部和UDP报文首部（含源和目的端口号）；如果封装的是TCP报文，则该8个字节也包括最关键的源/目的端口号字段。

![封装示意图](http://book.moecode.com/net/layer3/17.png)

ICMP的应用：Traceroute

如图所示，通过发送一系列TTL不同的分组（每个TTL发送3个报文）进行探测，且目的端口号设置为目的主机不可能使用的端口号，这样一来报文到达目的主机后就会返回目的不可达ICMP报文。一个问题：不是说每次经过的路径是不一样的吗？事实上在短时间内互联网的状态没有太大改变时，经过的路径一般是一样的。

![Traceroute原理图](http://book.moecode.com/net/layer3/18.png)

### IPv6简介

IPv6数据报格式：固定长度为40字节的基本首部，不允许分片，扩展首部和数据统称为载荷。

基本首部：版本号、优先级（以便网络区分对待不同数据报）、流标签、载荷长度、下一个首部（基本首部指向第一个扩展首部，第一个扩展首部指向第二个扩展首部……最后一个扩展首部指向传输层的UDP/TCP首部）、跳步限制（对应于IPv4中的TTL）、源地址（128位）、目的地址（128位）。

首部校验和彻底移除，以高效进行转发。选项转移到扩展首部。

ICMPv6：新版的ICMP，添加了比如提示分组太大的报文（因为路由器不能分片）。

IPv6地址格式：128位，分为8组，每组16位，写成16进制形式。连续多个0可以写成连续冒号的缩写形式，但是同一个地址不能有两次连续冒号，不然会有歧义。IPv6没有掩码，用类似于CIDR的方式以斜杠加数字的形式指明网络号长度。

![IPv6地址格式](http://book.moecode.com/net/layer3/19.png)

IPv6有三种基本地址类型：单播、多播、任意播。

IPv4到IPv6的过渡：隧道技术。IPv6数据报作为IPv4数据报的载荷进行封装，穿越IPv4网络。

### 路由算法

将网络抽象成图，权重一般设置为越小越好（比如带宽的倒数、拥塞程度等）。主要的问题就是求最小路径的问题。

路由算法的分类：

- 静态路由（手工配置、路由更新慢、优先级高）；动态路由（路由更新快：定期更新、及时响应链路费用或网络拓扑变化；优先级低）
- 全局信息（所有路由器掌握完整的网络拓扑和链路费用信息，代表有链路状态路由算法）；分散信息（路由器只掌握物理相连的邻居以及链路费用；邻居间的信息交换；代表有距离向量路由算法）

### 链路状态路由算法

路由器如何获得整个网络的信息？每个路由器构造链路信息分组（比如带上自己邻居的信息以及路径的费用等）进行广播，当每个路由器都收到其所在网络的所有路由器的链路信息分组，那么每个路由器都掌握了这一张图。

接着使用Dijkstra算法计算从一个结点到达所有其他结点的最短路径，从而获得该结点的转发表。算法经过k次迭代，得到到达k个目的结点的最短路径。

符号：

- c(x, y)表示结点 x 和 y 链路费用，如果二者不直接相连则值为无穷大
- D(v)表示从源到目的v的当前路径费用值（不一定是最短路径）
- p(v)表示沿从源到v的当前路径，v的前序结点
- N'表示已经找到最小费用路径的结点集合（当N'等于N时算法结束）

描述Dijkstra算法：

![算法伪代码](http://book.moecode.com/net/layer3/20.png)

算法举例：

![算法举例](http://book.moecode.com/net/layer3/21.png)

某次算法之后得到转发表的形式如下：

![转发表](http://book.moecode.com/net/layer3/22.png)

事实上会产生振荡问题。如下图所示：BCD路由器每次都有1、e、1的流量发送给A，由于不同时刻网络状态不同（此时通信量时链路费用，这是为了避免拥塞），所以更新过快会导致振荡，从而可能使分组在若干路由器之间来回走，最后TTL变为0从而被丢弃。

![振荡问题](http://book.moecode.com/net/layer3/23.png)

### 距离向量路由算法

在上面的链路状态路由算法中可知，最终放到路由转发表里面的只有去往目的主机需要转出的接口（对应路径上的下一个路由器，这是个邻居路由器）。Bellman-Ford方程引出的方法可以突出这种特征。

令d<sub>x</sub>(y)为从x到y的最短路径的费用，那么有：

d<sub>x</sub>(y) = min { c(x, v) + d<sub>v</sub>(y) }

其中c(x, v)是x到邻居v的费用，d<sub>v</sub>(y)是从邻居v到达目的y的最小费用。这个公式的意思是说x到y的最小费用，就是对于每个邻居，自己到邻居的费用加上邻居到目的的最小费用，所有值之中的最小值。

那如何获得d<sub>v</sub>(y)呢？事实上是每个路由器先进行自己到其他每个路由器最小费用的估计，得到估计值比如D<sub>x</sub>(y)，再进行一次次迭代最终使得估计值收敛于实际值。

对于x路由器，其需要维护一个距离向量D<sub>x</sub>=[D<sub>x</sub>(y): y属于N]，这个向量的每个值是x路由器到其他路由器到最小费用的估计值。且已知x到每个邻居的费用c(x, y)，进一步维护其所有邻居的距离向量D<sub>v</sub>=[D<sub>v</sub>(y): y属于N]。每个结点都不定时地将自身的距离向量发送给邻居，且当其收到邻居的新的距离向量估计时就要根据B-F方程更新自己的距离向量估计，这样一次次迭代就能使距离向量收敛到实际值。

每次引发局部迭代的因素有两个：局部链路费用的改变；来自邻居的距离向量的更新。

每个结点都要进行下面的循环：等待（触发因素：费用变/邻居变）->重新估计->告诉邻居->继续等待->……

一个迭代过程的例子如下图所示：

![距离向量路由算法举例](http://book.moecode.com/net/layer3/24.png)

关于链路费用变化引起的更新和无穷计数问题可参考如下课件图片，文字描述以后再补充。

![](http://book.moecode.com/net/layer3/25.png)

![](http://book.moecode.com/net/layer3/26.png)

![](http://book.moecode.com/net/layer3/27.png)

### 层次化路由

将任意规模的网络抽象成一个图进行计算过于理想化，因为规模太大的时候根本搞不定，比如路由表没法存储，链路状态分组的交换量巨大，淹没链路。同时不同的网络可能希望控制内网的路由。所以现在的互联网是网络的网络，也就是层次化路由。

聚合路由器为一个区域：自治系统AS。那么路由就分为两级：自治系统内和自治系统之间。同一个AS内的路由器运算相同的路由协议，也就是“自治系统内路由协议”。不同自治系统内的路由器可以运行不同的AS内部路由协议。

网关路由器位于AS边缘，通过链路连接其他AS的网关路由器，实现自治系统之间的路由交换。

转发表由AS内部路由算法和AS间的路由算法共同配置：AS内部路由算法设置AS内部目的网络路由入口，AS内部路由算法与AS间路由算法共同设置AS外部目的网络路由入口。

当AS1内的某路由器收到目的地址在AS1之外的数据报的时候，要确定该数据报应该要发送给哪个网关路由器。因此，自治系统间的路由任务有：

- 让某个自治系统知道去往某个网络要经过哪个相邻的自治系统（网络可达性信息）
- 将网络可达性信息（包括网关路由器信息）传播给这个自治系统内部的所有路由器

当某个路由器有了这些网络可达性信息，当收到一个去往自治系统外的数据报时，由自治系统内的任务知道到达对应的网络所需经过的网关路由器的最短路径应该从哪个接口出发，就可以顺利完成转发任务（在转发表中有去往 x 网络的最小费用路径接口）。

![转发表设置](http://book.moecode.com/net/layer3/28.png)

如果数据报想去的某个子网可以通过不同的自治系统到达，也就是说路由器可以将其转发给不同的网关路由器，那么应该怎么选择呢？这个选择也是有AS间的路由协议来完成的，叫做热土豆路由。可以想象数据分组是个热土豆，希望尽快地将它从自治系统中抛出去，所以将分组发送给最近的网关路由器。流程如下图所示：

![热土豆路由流程](http://book.moecode.com/net/layer3/29.png)

### RIP协议

Internet采用层次路由，AS的内部路由协议也称为内部网络协议IGP（interior gateway protocols）。常见的IGP有：

- 路由信息协议：RIP（Routing Information Protocol）
- 开放最短路径优先协议：OSPF（Open Shortest Path First）
- 内部网关路由协议：IGRP（Interior Gateway Routing Protocol）是Cisco的私有协议

RIP利用了距离向量路由算法，其配置为：

- 距离度量：跳步数（最大度量为15跳，16跳步就是无穷大），每条链路一个跳步
- 每隔30秒，邻居之间交换一次DV（距离向量），称为通告
- 每次通告最多包含25个目的子网（IP地址形式）

RIP具体例子可以参见MOOC，其在路由表上加上的“下一跳”这一项，可以利用这一项实现毒性逆转（看下一跳是不是自己）。

RIP还要处理链路的失效和恢复问题。如果路由器180秒没有收到通告，则认为邻居/链路失效。这时经过该邻居的路由不可用，需要重新计算路由，向邻居发送通告，邻居再向邻居的邻居发送通告（如果转发表/距离向量发生改变），一步步扩散。仍可能产生无穷技术问题，但是由于定义了毒性逆转和最大度量，所以能够有效缓解。

由于RIP的跳步最大度量为15，所以其适用于较小规模的网络。

RIP路由表是利用一个叫做route-d的应用进程进行管理，也就是说它实际上是用应用进程来实现的。但是RIP仍然是一个网络层协议，因为其功能并不是面向端用户，而是为了实现网络层的一些功能。RIP中的通告报文是定期发送UDP报文来实现的。

### OSPF协议

“开放”指的是公众可用。其采用链路状态路由算法。路由器发放LS（链路状态）分组进行通告，每个路由器都能收到所有其他路由器的链路状态，从而维护一个链路状态数据库，构造出一个完整的网络拓扑图，进而可以利用Dijkstra算法计算路由。OSPF通告中每一个入口对应一个邻居（信息包含例如邻居ID和路径费用），OSPF通告会在整个AS范围内泛洪。OSPF报文直接封装在IP数据报中进行传输。

OSPF相对于RIP的优点：

- 更安全：OSPF报文需要进行认证才能被采纳使用（预防恶意入侵）
- 允许使用多条相同费用的路径（RIP只能选一条），这样就类似于带宽增加了。
- 对于每一条链路，可以针对不同的TOS（服务类型）设置多个不同的费用度量。比如卫星链路可以针对尽力而为的ToS设置低费用，对实时ToS设置高费用，这时该链路就倾向于传输尽力而为类型的数据报，实现不同服务类型数据的分流。
- 集成单播路由与多播路由
- OSPF支持对大规模AS分层。

![分层的OSPF](http://book.moecode.com/net/layer3/30.png)

OSPF实际上是一个AS内的路由协议，其可以在AS内部进一步划分区域，得到两级分层：局部区（Area）和主干区（Backbone）。链路状态通告只限于区内，每个路由器只需掌握所在区的详细拓扑，只需知道去往其他区网络的方向。有三类路由器：

- 内部路由器IR（Internal Routers）
- 区边界路由器ABR（Area Border Routers）：既属于局部区又属于主干区，功能是聚集其所在的局部区网络的各个距离信息，并将这些信息通告给其他区边界路由器。
- 主干路由器BR（Backbone Routers）：在主干区内运行OSPF路由算法。
- AS边界路由器ASBR（AS Boundary Routers）：连接其他AS。相当于网关路由器，可以有多个。

### BGP协议

BGP（Border Gateway Protocol，边界网关协议）是Internet中的AS间路由协议。其为每个AS提供了一种手段去：

- eBGP：从邻居AS获取子网的可达性信息
- iBGP：向所有AS内部路由器传播子网可达性信息
- 基于可达性信息和策略，确定到达其他网络的“好”路径（不一定是费用最少，可能要考虑到政策问题）

BGP会话：两个BGP路由器（Peers）交换BGP报文：

- 通告去往不同目的前缀的路径（交换目的可达性信息），有时候称为“路径向量协议”（距离向量协议只是提供最小距离信息，而这里提供了完整的路径信息）
- 报文交换基于半永久的TCP连接（也是基于应用进程来实现的）

BGP报文：

- OPEN：与peer建立TCP连接，并认证发送方
- UPDATE：通告新路径（或撤销原路径）
- KEEPALIVE：在无UPDATE时保活连接，也用于对OPEN请求的确认
- NOTIFICATION：进行差错报告，也可用于拆除连接

当一个自治系统通告前缀给另一个自治系统时：

- 其承诺可以将数据报转发给该前缀对应的子网
- 其在通告中会聚合网络前缀（可以减少可达性信息量）

 eBGP是外部会话，不同的AS之间交换可达性信息。iBGP是内部会话，在网络内部分发可达性信息。当路由器得到可达性信息后，会在转发表中增加对应的路由项。

每个可达性信息的路由项应该包含**前缀**和**属性**两部分内容，其中属性包含**AS路径**和**下一跳**两部分内容，注意“下一跳”实际上是一个IP地址。如果从当前AS到下一个AS存在多条链路，则采用热土豆路由。

![路径属性与BGP路由](http://book.moecode.com/net/layer3/31.png)

BGP路由的选择：当网关路由器收到路由通告后，会利用其输入策略接受/拒绝该路由，所以称为基于策略的路由。比如策略可以是“不经过某个AS”，以及类似的约束条件。当路由器获知到达目的AS的多条路由时如何进行选择呢？可以基于以下准则进行选择：

- 本地偏好值属性：基于策略的决策
- 最短AS路径（经过的AS最少，不一定是经过的路由器最少，因为二者不在一个层上）
- 最近的NEXT-HOP路由器：热土豆路由
- 附加准则

路由选择策略举例：

![](http://book.moecode.com/net/layer3/32.png)

![](http://book.moecode.com/net/layer3/33.png)









